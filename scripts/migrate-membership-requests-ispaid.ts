/**
 * Script de migration pour ajouter le champ `isPaid: false` aux documents existants
 * dans la collection `membership-requests` du projet dev.
 * 
 * Ce script met Ã  jour uniquement les documents qui n'ont pas encore le champ `isPaid`.
 * 
 * Usage:
 *   pnpm tsx scripts/migrate-membership-requests-ispaid.ts
 * 
 * Ou avec Node:
 *   npx ts-node scripts/migrate-membership-requests-ispaid.ts
 */

import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getFirestore } from 'firebase-admin/firestore'
import * as path from 'path'
import * as fs from 'fs'
import { fileURLToPath } from 'url'

// Configuration du projet dev
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const SERVICE_ACCOUNT_PATH = process.env.GOOGLE_APPLICATION_CREDENTIALS ||
  path.join(__dirname, '../service-accounts/kara-gabon-dev-firebase-adminsdk-fbsvc-449838b888.json')

const COLLECTION_NAME = 'membership-requests'
const FIELD_NAME = 'isPaid'
const FIELD_VALUE = false

async function migrate() {
  console.log('ğŸš€ DÃ©marrage de la migration...\n')
  console.log(`ğŸ“‹ Collection: ${COLLECTION_NAME}`)
  console.log(`ğŸ“‹ Champ Ã  ajouter: ${FIELD_NAME} = ${FIELD_VALUE}\n`)

  // Initialiser Firebase Admin
  if (getApps().length === 0) {
    try {
      // VÃ©rifier que le fichier service account existe
      if (!fs.existsSync(SERVICE_ACCOUNT_PATH)) {
        throw new Error(`Fichier service account non trouvÃ©: ${SERVICE_ACCOUNT_PATH}`)
      }

      const serviceAccount = JSON.parse(fs.readFileSync(SERVICE_ACCOUNT_PATH, 'utf-8'))
      
      initializeApp({
        credential: cert(serviceAccount as any),
        projectId: serviceAccount.project_id,
      })
      console.log(`âœ… Firebase Admin initialisÃ© pour le projet: ${serviceAccount.project_id}\n`)
    } catch (error: any) {
      console.error('âŒ Erreur lors de l\'initialisation de Firebase Admin:', error.message)
      console.log('\nğŸ’¡ Assurez-vous que le fichier service account existe:')
      console.log(`   ${SERVICE_ACCOUNT_PATH}`)
      process.exit(1)
    }
  }

  const db = getFirestore()
  let totalUpdated = 0
  let totalSkipped = 0
  let totalErrors = 0

  try {
    console.log(`ğŸ“‚ RÃ©cupÃ©ration des documents de la collection "${COLLECTION_NAME}"...`)
    const snapshot = await db.collection(COLLECTION_NAME).get()
    const totalDocuments = snapshot.size
    console.log(`   âœ… ${totalDocuments} documents trouvÃ©s\n`)

    if (totalDocuments === 0) {
      console.log('âœ¨ Aucun document Ã  migrer.')
      return
    }

    let batch = db.batch()
    let batchCount = 0
    const MAX_BATCH_SIZE = 500 // Limite Firestore par batch

    console.log(`ğŸ”„ Traitement des documents...\n`)

    for (const docSnap of snapshot.docs) {
      const data = docSnap.data()
      const docId = docSnap.id

      // VÃ©rifier si le champ existe dÃ©jÃ 
      if (FIELD_NAME in data) {
        // Le champ existe dÃ©jÃ , on le laisse tel quel
        totalSkipped++
        continue
      }

      // Ajouter le champ avec la valeur par dÃ©faut
      try {
        batch.update(docSnap.ref, { [FIELD_NAME]: FIELD_VALUE })
        batchCount++
        totalUpdated++

        // Afficher un log tous les 100 documents
        if (totalUpdated % 100 === 0) {
          console.log(`   â³ ${totalUpdated} documents prÃ©parÃ©s pour mise Ã  jour...`)
        }

        // Commit le batch si trop grand et crÃ©er un nouveau batch
        if (batchCount >= MAX_BATCH_SIZE) {
          await batch.commit()
          console.log(`   âœ… Batch de ${batchCount} documents committÃ©`)
          batch = db.batch() // CrÃ©er un nouveau batch
          batchCount = 0
        }
      } catch (error: any) {
        console.error(`   âŒ Erreur pour le document ${docId}:`, error.message)
        totalErrors++
      }
    }

    // Commit le dernier batch s'il y en a un
    if (batchCount > 0) {
      await batch.commit()
      console.log(`   âœ… Dernier batch de ${batchCount} documents committÃ©\n`)
    }

    // RÃ©sumÃ©
    console.log('\nğŸ“Š RÃ©sumÃ© de la migration:')
    console.log(`   âœ… ${totalUpdated} documents mis Ã  jour`)
    console.log(`   â­ï¸  ${totalSkipped} documents ignorÃ©s (champ dÃ©jÃ  prÃ©sent)`)
    if (totalErrors > 0) {
      console.log(`   âŒ ${totalErrors} erreurs`)
    }
    console.log(`   ğŸ“ Total traitÃ©: ${totalUpdated + totalSkipped + totalErrors} / ${totalDocuments}\n`)

    if (totalUpdated > 0) {
      console.log('âœ¨ Migration terminÃ©e avec succÃ¨s!\n')
    } else {
      console.log('âœ¨ Aucune mise Ã  jour nÃ©cessaire. Tous les documents ont dÃ©jÃ  le champ `isPaid`.\n')
    }

  } catch (error: any) {
    console.error('\nâŒ Erreur lors de la migration:', error.message)
    console.error(error)
    process.exit(1)
  }
}

// ExÃ©cuter la migration
migrate()
  .then(() => {
    console.log('ğŸ‘‹ Script terminÃ©.')
    process.exit(0)
  })
  .catch((error) => {
    console.error('âŒ Erreur fatale:', error)
    process.exit(1)
  })
