@startuml CLASSES_MEMBERSHIP
skinparam packageStyle rectangle
skinparam class {
  BackgroundColor LightBlue
  BorderColor DarkBlue
  ArrowColor DarkBlue
}

title Diagramme de Classes - Module Membership

' ============================================
' RÉFÉRENCE AUX CLASSES PARTAGÉES
' ============================================
package "Shared" <<Cloud>> {
  class User {
    + id: string
    + matricule: string
    + roles: UserRole[]
    ...
  }
  
  class Document {
    + id: string
    + type: DocumentType
    + url: string
    ...
  }
  
  class Address {
    + province: string
    + city: string
    ...
  }
}

' ============================================
' CLASSE : MEMBERSHIP_REQUEST (Demande d'adhésion)
' ============================================
class MembershipRequest {
  + id: string
  + matricule: string
  + status: MembershipRequestStatus
  + isPaid?: boolean
  + identity: IdentityData
  + address: AddressData
  + company: CompanyData
  + documents: DocumentsData
  + processedAt?: Date
  + processedBy?: string
  + updatedBy?: string
  + adminComments?: string
  + memberNumber?: string
  + reviewNote?: string
  + motifReject?: string
  + payments?: Payment[]
  + securityCode?: string
  + securityCodeExpiry?: Date
  + securityCodeUsed?: boolean
  + securityCodeVerifiedAt?: Date
  + priorityScore?: number
  + approvedBy?: string
  + approvedAt?: Date
  + createdAt: Date
  + updatedAt: Date
}

' ============================================
' CLASSE : PAYMENT (Paiement)
' ============================================
class Payment {
  + date: Date
  + time: string
  + mode: PaymentMode
  + amount: number
  + acceptedBy: string
  + paymentType: TypePayment
  + withFees?: boolean
  + paymentMethodOther?: string
  + proofUrl?: string
  + proofPath?: string
  + recordedBy: string
  + recordedByName: string
  + recordedAt: Date
}

note right of Payment
  **Traçabilité du paiement:**
  
  **date** : Date de versement
  (quand le client a effectué le paiement)
  
  **recordedAt** : Date d'enregistrement
  (quand l'admin a enregistré le paiement)
  
  **recordedBy** : ID de l'admin qui a enregistré
  
  **recordedByName** : Nom complet de l'admin
  (prénom + nom)
  
  **Exemple:**
  - Client paie le 15/01/2025 à 10h30
  - Admin enregistre le 16/01/2025 à 14h00
  → date = 15/01/2025, recordedAt = 16/01/2025
  
  **Stockage:**
  - Dupliqué dans membership-requests[].payments[]
  - Centralisé dans collection "payments" (historique global)
end note

' ============================================
' CLASSE : CENTRALIZED_PAYMENT (Paiement centralisé)
' ============================================
class CentralizedPayment {
  + id: string
  + date: Date
  + time: string
  + mode: PaymentMode
  + amount: number
  + acceptedBy: string
  + paymentType: TypePayment
  + withFees?: boolean
  + paymentMethodOther?: string
  + proofUrl?: string
  + proofPath?: string
  + recordedBy: string
  + recordedByName: string
  + recordedAt: Date
  + sourceType: string
  + sourceId: string
  + beneficiaryId?: string
  + beneficiaryName?: string
  + createdAt: Date
  + updatedAt: Date
}

note right of CentralizedPayment
  **Collection Firestore:** payments
  Clé primaire: id (auto-généré)
  
  **Rôle:**
  Historique centralisé de TOUS les versements
  (adhésion, caisse spéciale, crédit, placement, etc.)
  
  **sourceType:** Type de source
  (membership-request, caisse-speciale, etc.)
  
  **sourceId:** ID du document source
  
  **Index recommandés:**
  - sourceType + sourceId
  - beneficiaryId
  - date (desc)
  - recordedBy
  - paymentType
end note

' ============================================
' CLASSE : IDENTITY_DATA (Données d'identité)
' ============================================
class IdentityData {
  + civility: string
  + lastName: string
  + firstName: string
  + birthDate: string
  + birthPlace: string
  + birthCertificateNumber: string
  + prayerPlace: string
  + religion: string
  + contacts: string[]
  + email?: string
  + gender: string
  + nationality: string
  + maritalStatus: string
  + spouseLastName?: string
  + spouseFirstName?: string
  + spousePhone?: string
  + intermediaryCode?: string
  + hasCar: boolean
  + photoURL?: string
  + photoPath?: string
}

' ============================================
' CLASSE : ADDRESS_DATA (Données d'adresse)
' ============================================
class AddressData {
  + province: string
  + city: string
  + district: string
  + arrondissement: string
  + additionalInfo?: string
}

' ============================================
' CLASSE : COMPANY_DATA (Données d'entreprise)
' ============================================
class CompanyData {
  + isEmployed: boolean
  + companyName?: string
  + companyAddress?: CompanyAddressData
  + profession?: string
  + seniority?: string
}

' ============================================
' CLASSE : COMPANY_ADDRESS_DATA
' ============================================
class CompanyAddressData {
  + province?: string
  + city?: string
  + district?: string
}

' ============================================
' CLASSE : DOCUMENTS_DATA (Données de documents)
' ============================================
class DocumentsData {
  + identityDocument: string
  + identityDocumentNumber: string
  + documentPhotoFrontURL?: string
  + documentPhotoFrontPath?: string
  + documentPhotoBackURL?: string
  + documentPhotoBackPath?: string
  + expirationDate: string
  + issuingPlace: string
  + issuingDate: string
}

' ============================================
' CLASSE : GROUP (Groupe)
' ============================================
class Group {
  + id: string
  + name: string
  + label?: string
  + description?: string
  + createdAt: Date
  + createdBy: string
  + updatedAt: Date
  + updatedBy?: string
}

' ============================================
' CLASSE : SUBSCRIPTION (Souscription)
' ============================================
class Subscription {
  + id: string
  + userId: string
  + dateStart: Date
  + dateEnd: Date
  + montant: number
  + currency: string
  + type: MembershipType
  + isValid?: boolean
  + adhesionPdfURL?: string
  + adhesionPdfPath?: string
  + createdAt: Date
  + updatedAt: Date
  + createdBy: string
}

' ============================================
' CLASSES : FONCTIONNALITÉ CORRECTIONS
' ============================================

' Classe d'entité pour la demande de correction (frontend)
class CorrectionRequest {
  + requestId: string
  + reviewNote: string
  + securityCode: string
  + isVerified: boolean
}

' Structure de données du formulaire d'inscription
class RegisterFormData {
  + identity: IdentityData
  + address: AddressData
  + company: CompanyData
  + documents: DocumentsData
}

' ============================================
' CLASSES : FONCTIONNALITÉ APPROBATION
' ============================================

' Paramètres d'entrée pour l'approbation
class ApproveMembershipRequestInput {
  + requestId: string
  + adminId: string
  + membershipType: MembershipType
  + companyId?: string
  + professionId?: string
  + adhesionPdfURL: string
}

' Réponse de la Cloud Function d'approbation
class ApproveMembershipRequestOutput {
  + success: boolean
  + matricule: string
  + email: string
  + password: string
  + subscriptionId: string
  + companyId?: string
  + professionId?: string
}

' ============================================
' CLASSES : SERVICES (Architecture V2)
' ============================================

class MembershipServiceV2 {
  - repository: MembershipRepositoryV2
  - adminRepository: AdminRepository
  + {static} getInstance(): MembershipServiceV2
  + requestCorrections(params: RequestCorrectionsParams): Promise<{securityCode: string, whatsAppUrl?: string}>
  + approveMembershipRequest(params: ApproveMembershipRequestParams): Promise<ApproveMembershipRequestOutput>
  + rejectMembershipRequest(params: RejectMembershipRequestParams): Promise<void>
  + processPayment(params: ProcessPaymentParams): Promise<void>
}

note right of MembershipServiceV2
  **Note:** AdminRepository est défini dans CLASSES_AUTH.puml
  Utilisé pour valider l'identité de l'admin lors des opérations
end note

class RegistrationService {
  - repository: IRegistrationRepository
  + submitRegistration(data: RegisterFormData): Promise<string>
  + updateRegistration(requestId: string, data: RegisterFormData): Promise<boolean>
  + verifySecurityCode(requestId: string, code: string): Promise<boolean>
  + loadRegistrationForCorrection(requestId: string): Promise<RegisterFormData | null>
  + validateStep(step: number, data: Partial<RegisterFormData>): Promise<StepValidationResult>
}

' ============================================
' CLASSES : REPOSITORIES (Architecture V2)
' ============================================

class MembershipRepositoryV2 {
  - collectionName: string
  - paymentRepository: PaymentRepositoryV2
  + {static} getInstance(): MembershipRepositoryV2
  + getById(id: string): Promise<MembershipRequest | null>
  + updateStatus(id: string, status: MembershipRequestStatus, data: Partial<MembershipRequest>): Promise<void>
  + markAsPaid(id: string, paymentInfo: PaymentInfo): Promise<void>
  + getPaginated(filters: MembershipRequestFilters): Promise<MembershipRequestsResponse>
}

class RegistrationRepository {
  + getById(id: string): Promise<MembershipRequest | null>
  + create(data: RegisterFormData): Promise<string>
  + update(id: string, data: Partial<RegisterFormData>): Promise<boolean>
  + verifySecurityCode(requestId: string, code: string): Promise<boolean>
  + markSecurityCodeAsUsed(requestId: string): Promise<boolean>
}

' ============================================
' CLASSES : CLOUD FUNCTIONS
' ============================================

class ApproveMembershipRequestCloudFunction {
  + {callable} approveMembershipRequest(input: ApproveMembershipRequestInput): Promise<ApproveMembershipRequestOutput>
  - validateRequest(requestId: string): Promise<MembershipRequest>
  - generateEmail(firstName: string, lastName: string, matricule: string): string
  - generateSecurePassword(length: number): string
  - createFirebaseAuthUser(matricule: string, email: string, password: string): Promise<UserRecord>
  - createUserDocument(matricule: string, data: UserData): Promise<void>
  - createSubscription(memberId: string, membershipType: MembershipType, adhesionPdfURL: string): Promise<string>
  - archiveAdhesionDocument(matricule: string, adhesionPdfURL: string): Promise<string>
  - createApprovalNotification(requestId: string, matricule: string, memberName: string, email: string, adminId: string): Promise<void>
  - rollback(actions: RollbackAction[]): Promise<void>
}

' ============================================
' CLASSES : UTILITAIRES
' ============================================

class SecurityCodeUtils {
  + {static} generateSecurityCode(): string
  + {static} calculateCodeExpiry(hours: number): Date
}

class WhatsAppUrlUtils {
  + {static} generateWhatsAppUrl(phoneNumber: string, message: string): string
}

class PDFGenerator {
  + {static} generateCredentialsPDF(firstName: string, lastName: string, matricule: string, email: string, password: string): Blob
  + {static} downloadPDF(blob: Blob, filename: string): void
}

' ============================================
' TYPES ENUMERÉS
' ============================================
enum MembershipRequestStatus {
  pending
  approved
  rejected
  under_review
}

enum PaymentMode {
  airtel_money
  mobicash
  cash
  bank_transfer
  other
}

enum TypePayment {
  Membership
  Subscription
  Tontine
  Charity
}

enum MembershipType {
  adherant
  bienfaiteur
  sympathisant
}

' ============================================
' RELATIONS
' ============================================

' MembershipRequest contient IdentityData (composition)
MembershipRequest *-- IdentityData : contains

' MembershipRequest contient AddressData (composition)
MembershipRequest *-- AddressData : contains

' MembershipRequest contient CompanyData (composition)
MembershipRequest *-- CompanyData : contains

' MembershipRequest contient DocumentsData (composition)
MembershipRequest *-- DocumentsData : contains

' CompanyData contient CompanyAddressData (composition)
CompanyData *-- CompanyAddressData : contains

' MembershipRequest peut devenir User (après validation)
MembershipRequest ..> User : becomes

' MembershipRequest peut avoir plusieurs Payment (agrégation)
MembershipRequest "1" --> "*" Payment : has

' User peut avoir plusieurs Subscription (agrégation)
User "1" --> "*" Subscription : has

' Group référence User (via membres dans User, pas de relation directe dans Firestore)
' Note: Les groupes stockent les IDs des membres dans User.groups ou via une sous-collection
User "1" --> "*" Group : belongs_to

' User peut avoir plusieurs Documents (agrégation - référencé depuis Shared)
User "1" --> "*" Document : has

' ============================================
' RELATIONS : FONCTIONNALITÉ CORRECTIONS
' ============================================

' MembershipRequest peut avoir une CorrectionRequest active
MembershipRequest ..> CorrectionRequest : can have

' RegisterFormData utilise les mêmes structures de données que MembershipRequest
RegisterFormData *-- IdentityData : contains
RegisterFormData *-- AddressData : contains
RegisterFormData *-- CompanyData : contains
RegisterFormData *-- DocumentsData : contains

' ============================================
' RELATIONS : FONCTIONNALITÉ APPROBATION
' ============================================

' MembershipRequest peut être approuvée via Cloud Function
MembershipRequest ..> ApproveMembershipRequestCloudFunction : approved_by

' MembershipRequest génère un Document (PDF d'adhésion) lors de l'approbation
MembershipRequest "1" --> "0..1" Document : generates_adhesion_pdf
note right of Document
  **Type:** ADHESION
  **Format:** pdf
  **Créé lors de l'approbation**
  **Stocké dans collection "documents"**
end note

' ApproveMembershipRequestInput est utilisé par la Cloud Function
ApproveMembershipRequestCloudFunction ..> ApproveMembershipRequestInput : uses
ApproveMembershipRequestCloudFunction ..> ApproveMembershipRequestOutput : returns

' Cloud Function crée un User lors de l'approbation
ApproveMembershipRequestCloudFunction ..> User : creates

' Cloud Function crée une Subscription lors de l'approbation
ApproveMembershipRequestCloudFunction ..> Subscription : creates

' Cloud Function archive un Document lors de l'approbation
ApproveMembershipRequestCloudFunction ..> Document : archives

' Services utilisent leurs repositories respectifs
MembershipServiceV2 --> MembershipRepositoryV2 : uses
MembershipServiceV2 --> AdminRepository : uses
RegistrationService --> RegistrationRepository : uses

' MembershipServiceV2 appelle la Cloud Function pour l'approbation
MembershipServiceV2 ..> ApproveMembershipRequestCloudFunction : calls

' Repositories interagissent avec MembershipRequest
MembershipRepositoryV2 ..> MembershipRequest : queries/updates
RegistrationRepository ..> MembershipRequest : queries/updates

' Services utilisent les utilitaires
MembershipServiceV2 ..> SecurityCodeUtils : uses
MembershipServiceV2 ..> WhatsAppUrlUtils : uses
MembershipServiceV2 ..> PDFGenerator : uses

' RegistrationRepository utilise SecurityCodeUtils pour marquer le code comme utilisé
RegistrationRepository ..> SecurityCodeUtils : uses

note right of MembershipRequest
  **Collection Firestore:** membership-requests
  Clé primaire: id
  Index sur: status, createdAt, matricule, isPaid, approvedBy, approvedAt
  
  **Workflow métier:**
  - isPaid: false par défaut (migration appliquée)
  - Paiement requis avant approbation
  - Filtrage par statut de paiement (Payées/Non payées)
  
  **Fonctionnalité Corrections:**
  - reviewNote: Liste des corrections demandées
  - securityCode: Code à 6 chiffres (généré aléatoirement)
  - securityCodeExpiry: Expiration 48h après génération
  - securityCodeUsed: Marqué à true après utilisation
  - Statut passe à 'under_review' lors de la demande de correction
  - Statut repasse à 'pending' après soumission des corrections
  
  **Fonctionnalité Approbation:**
  - approvedBy: ID de l'admin qui a approuvé (obligatoire, pour traçabilité)
  - approvedAt: Date d'approbation (obligatoire, timestamp serveur)
  - Statut passe à 'approved' après approbation
  - Génère un User, une Subscription et un Document (PDF d'adhésion)
  - Ces champs permettent l'audit et la traçabilité des approbations
end note

note right of MembershipServiceV2
  **Service métier V2 pour Membership Requests**
  
  **Méthode requestCorrections():**
  - Valide les corrections (non vide, chaque ligne non vide)
  - Génère securityCode (6 chiffres)
  - Calcule securityCodeExpiry (+48h)
  - Met à jour statut à 'under_review'
  - Génère URL WhatsApp si numéro disponible
  - Retourne {securityCode, whatsAppUrl}
  
  **Méthode approveMembershipRequest():**
  - Valide les paramètres (requestId, adminId, membershipType, adhesionPdfURL)
  - Upload PDF d'adhésion vers Firebase Storage
  - Appelle Cloud Function approveMembershipRequest
  - Génère et télécharge PDF des identifiants (email + password)
  - Retourne ApproveMembershipRequestOutput
  
  **Architecture:**
  - Singleton pattern
  - Utilise MembershipRepositoryV2 pour accès données
  - Utilise AdminRepository pour validation admin
  - Appelle Cloud Function pour approbation atomique
end note

note right of RegistrationService
  **Service pour la gestion des inscriptions et corrections**
  
  **Méthodes principales:**
  - verifySecurityCode(): Vérifie code (format, correspondance, expiration, usage)
  - loadRegistrationForCorrection(): Charge données demande pour pré-remplir formulaire
  - updateRegistration(): Met à jour demande avec corrections (status → 'pending', securityCodeUsed → true)
  - submitRegistration(): Crée nouvelle demande
  
  **Architecture:**
  - Utilise RegistrationRepository pour accès données
  - Transforme MembershipRequest ↔ RegisterFormData
end note

note right of SecurityCodeUtils
  **Utilitaires pour codes de sécurité**
  
  **generateSecurityCode():**
  - Génère code aléatoire à 6 chiffres (100000-999999)
  - Utilise crypto.randomInt() pour sécurité
  
  **calculateCodeExpiry(hours: number):**
  - Calcule date d'expiration
  - Par défaut: 48 heures après génération
  - Retourne Date
end note

note right of WhatsAppUrlUtils
  **Utilitaires pour génération URLs WhatsApp**
  
  **generateWhatsAppUrl(phoneNumber, message):**
  - Formate numéro (supprime espaces, +, etc.)
  - Encode message en URL
  - Retourne URL format: https://wa.me/{phoneNumber}?text={encodedMessage}
  
  **Utilisation:**
  - Admin peut sélectionner parmi plusieurs numéros
  - Message pré-rempli avec corrections et code de sécurité
end note

note right of ApproveMembershipRequestCloudFunction
  **Cloud Function Callable pour approbation atomique**
  
  **Opérations atomiques:**
  1. Validation (paiement, statut, permissions)
  2. Génération email et mot de passe
  3. Création utilisateur Firebase Auth
  4. Création document users
  5. Création abonnement subscriptions
  6. Archivage document PDF (collection documents)
  7. Mise à jour statut membership-requests
  8. Création notification
  
  **Workflow PDF d'adhésion:**
  1. Admin upload PDF dans le modal d'approbation
  2. PDF uploadé vers Firebase Storage (chemin: membership-adhesion-pdfs/)
  3. URL du PDF récupérée (adhesionPdfURL)
  4. Cloud Function archive dans collection "documents"
  5. Document créé avec type='ADHESION', memberId=matricule
  
  **Rollback automatique:**
  - Si une étape échoue, annule toutes les opérations précédentes
  - Supprime User Auth, document users, subscription, document PDF
  - Note: PDF dans Storage reste (peut être nettoyé manuellement)
  
  **Sécurité:**
  - Mot de passe retourné uniquement dans la réponse HTTPS
  - Jamais stocké en Firestore
  - Firebase Auth gère le stockage sécurisé
  
  **Fichier:** functions/src/membership-requests/approveMembershipRequest.ts
end note

note right of PDFGenerator
  **Générateur de PDF pour identifiants de connexion**
  
  **generateCredentialsPDF():**
  - Utilise jsPDF pour générer PDF côté client
  - Contient: Logo KARA, informations membre, email, password
  - Format: Identifiants_Connexion_{matricule}_{date}.pdf
  
  **downloadPDF():**
  - Télécharge automatiquement le PDF généré
  - Appelé immédiatement après génération
  
  **Utilisation:**
  - Après approbation réussie
  - PDF contient les identifiants pour le membre
  - Téléchargement automatique pour l'admin
end note

note right of User
  **Collection Firestore:** users
  Clé primaire: id (égal à matricule et UID Firebase)
  Relation avec MembershipRequest: après validation
end note

note right of Group
  **Collection Firestore:** groups
  Clé primaire: id
  Relation avec User: indirecte (via User.groups ou sous-collection)
end note

note right of Subscription
  **Collection Firestore:** subscriptions
  Clé primaire: id
  Index sur: userId, dateStart, dateEnd
end note

@enduml
