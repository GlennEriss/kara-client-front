@startuml CLASSES_MEMBERSHIP
skinparam packageStyle rectangle
skinparam class {
  BackgroundColor LightBlue
  BorderColor DarkBlue
  ArrowColor DarkBlue
}

title Diagramme de Classes - Module Membership

' ============================================
' RÉFÉRENCE AUX CLASSES PARTAGÉES
' ============================================
package "Shared" <<Cloud>> {
  class User {
    + id: string
    + matricule: string
    + roles: UserRole[]
    ...
  }
  
  class Document {
    + id: string
    + type: DocumentType
    + url: string
    ...
  }
  
  class Address {
    + province: string
    + city: string
    ...
  }
}

' ============================================
' CLASSE : MEMBERSHIP_REQUEST (Demande d'adhésion)
' ============================================
class MembershipRequest {
  + id: string
  + matricule: string
  + status: MembershipRequestStatus
  + isPaid?: boolean
  + identity: IdentityData
  + address: AddressData
  + company: CompanyData
  + documents: DocumentsData
  + processedAt?: Date
  + processedBy?: string
  + updatedBy?: string
  + adminComments?: string
  + memberNumber?: string
  + reviewNote?: string
  + motifReject?: string
  + payments?: Payment[]
  + securityCode?: string
  + securityCodeExpiry?: Date
  + securityCodeUsed?: boolean
  + securityCodeVerifiedAt?: Date
  + priorityScore?: number
  + approvedBy?: string
  + approvedAt?: Date
  + reopenedBy?: string
  + reopenedAt?: Date
  + reopenReason?: string
  + createdAt: Date
  + updatedAt: Date
}

' ============================================
' CLASSE : PAYMENT (Paiement)
' ============================================
class Payment {
  + date: Date
  + time: string
  + mode: PaymentMode
  + amount: number
  + acceptedBy: string
  + paymentType: TypePayment
  + withFees?: boolean
  + paymentMethodOther?: string
  + proofUrl?: string
  + proofPath?: string
  + recordedBy: string
  + recordedByName: string
  + recordedAt: Date
}

note right of Payment
  **Traçabilité du paiement:**
  
  **date** : Date de versement
  (quand le client a effectué le paiement)
  
  **recordedAt** : Date d'enregistrement
  (quand l'admin a enregistré le paiement)
  
  **recordedBy** : ID de l'admin qui a enregistré
  
  **recordedByName** : Nom complet de l'admin
  (prénom + nom)
  
  **Exemple:**
  - Client paie le 15/01/2025 à 10h30
  - Admin enregistre le 16/01/2025 à 14h00
  → date = 15/01/2025, recordedAt = 16/01/2025
  
  **Stockage:**
  - Dupliqué dans membership-requests[].payments[]
  - Centralisé dans collection "payments" (historique global)
end note

' ============================================
' CLASSE : CENTRALIZED_PAYMENT (Paiement centralisé)
' ============================================
class CentralizedPayment {
  + id: string
  + date: Date
  + time: string
  + mode: PaymentMode
  + amount: number
  + acceptedBy: string
  + paymentType: TypePayment
  + withFees?: boolean
  + paymentMethodOther?: string
  + proofUrl?: string
  + proofPath?: string
  + recordedBy: string
  + recordedByName: string
  + recordedAt: Date
  + sourceType: string
  + sourceId: string
  + beneficiaryId?: string
  + beneficiaryName?: string
  + createdAt: Date
  + updatedAt: Date
}

note right of CentralizedPayment
  **Collection Firestore:** payments
  Clé primaire: id (auto-généré)
  
  **Rôle:**
  Historique centralisé de TOUS les versements
  (adhésion, caisse spéciale, crédit, placement, etc.)
  
  **sourceType:** Type de source
  (membership-request, caisse-speciale, etc.)
  
  **sourceId:** ID du document source
  
  **Index recommandés:**
  - sourceType + sourceId
  - beneficiaryId
  - date (desc)
  - recordedBy
  - paymentType
end note

' ============================================
' CLASSE : IDENTITY_DATA (Données d'identité)
' ============================================
class IdentityData {
  + civility: string
  + lastName: string
  + firstName: string
  + birthDate: string
  + birthPlace: string
  + birthCertificateNumber: string
  + prayerPlace: string
  + religion: string
  + contacts: string[]
  + email?: string
  + gender: string
  + nationality: string
  + maritalStatus: string
  + spouseLastName?: string
  + spouseFirstName?: string
  + spousePhone?: string
  + intermediaryCode?: string
  + hasCar: boolean
  + photoURL?: string
  + photoPath?: string
}

' ============================================
' CLASSE : ADDRESS_DATA (Données d'adresse)
' ============================================
class AddressData {
  + province: string
  + city: string
  + district: string
  + arrondissement: string
  + additionalInfo?: string
}

' ============================================
' CLASSE : COMPANY_DATA (Données d'entreprise)
' ============================================
class CompanyData {
  + isEmployed: boolean
  + companyName?: string
  + companyAddress?: CompanyAddressData
  + profession?: string
  + seniority?: string
}

' ============================================
' CLASSE : COMPANY_ADDRESS_DATA
' ============================================
class CompanyAddressData {
  + province?: string
  + city?: string
  + district?: string
}

' ============================================
' CLASSE : DOCUMENTS_DATA (Données de documents)
' ============================================
class DocumentsData {
  + identityDocument: string
  + identityDocumentNumber: string
  + documentPhotoFrontURL?: string
  + documentPhotoFrontPath?: string
  + documentPhotoBackURL?: string
  + documentPhotoBackPath?: string
  + expirationDate: string
  + issuingPlace: string
  + issuingDate: string
}

' ============================================
' CLASSE : GROUP (Groupe)
' ============================================
class Group {
  + id: string
  + name: string
  + label?: string
  + description?: string
  + createdAt: Date
  + createdBy: string
  + updatedAt: Date
  + updatedBy?: string
}

' ============================================
' CLASSE : SUBSCRIPTION (Souscription)
' ============================================
class Subscription {
  + id: string
  + userId: string
  + dateStart: Date
  + dateEnd: Date
  + montant: number
  + currency: string
  + type: MembershipType
  + isValid?: boolean
  + adhesionPdfURL?: string
  + adhesionPdfPath?: string
  + createdAt: Date
  + updatedAt: Date
  + createdBy: string
}

' ============================================
' CLASSES : FONCTIONNALITÉ CORRECTIONS
' ============================================

' Classe d'entité pour la demande de correction (frontend)
class CorrectionRequest {
  + requestId: string
  + reviewNote: string
  + securityCode: string
  + isVerified: boolean
}

' Structure de données du formulaire d'inscription
class RegisterFormData {
  + identity: IdentityData
  + address: AddressData
  + company: CompanyData
  + documents: DocumentsData
}

' ============================================
' CLASSES : FONCTIONNALITÉ APPROBATION
' ============================================

' Paramètres d'entrée pour l'approbation
class ApproveMembershipRequestInput {
  + requestId: string
  + adminId: string
  + membershipType: MembershipType
  + companyId?: string
  + professionId?: string
  + adhesionPdfURL: string
}

' Réponse de la Cloud Function d'approbation
class ApproveMembershipRequestOutput {
  + success: boolean
  + matricule: string
  + email: string
  + password: string
  + subscriptionId: string
  + companyId?: string
  + professionId?: string
}

' ============================================
' CLASSES : FONCTIONNALITÉ REJET
' ============================================

' Paramètres d'entrée pour le rejet
class RejectMembershipRequestParams {
  + requestId: string
  + adminId: string
  + reason: string
}

' Paramètres d'entrée pour la réouverture
class ReopenMembershipRequestParams {
  + requestId: string
  + adminId: string
  + reason: string
}

' Paramètres d'entrée pour la suppression
class DeleteMembershipRequestInput {
  + requestId: string
  + confirmedMatricule: string
}

' Réponse de la Cloud Function de suppression
class DeleteMembershipRequestOutput {
  + success: boolean
  + requestId: string
  + filesDeleted: number
  + deletedAt: string
}

' ============================================
' CLASSES : SERVICES (Architecture V2)
' ============================================

class MembershipServiceV2 {
  - repository: MembershipRepositoryV2
  - adminRepository: AdminRepository
  - notificationService: NotificationService
  + {static} getInstance(): MembershipServiceV2
  + requestCorrections(params: RequestCorrectionsParams): Promise<{securityCode: string, whatsAppUrl?: string}>
  + approveMembershipRequest(params: ApproveMembershipRequestParams): Promise<ApproveMembershipRequestOutput>
  + rejectMembershipRequest(params: RejectMembershipRequestParams): Promise<void>
  + reopenMembershipRequest(params: ReopenMembershipRequestParams): Promise<void>
  + processPayment(params: ProcessPaymentParams): Promise<void>
}

note right of MembershipServiceV2
  **Service métier V2 pour Membership Requests**
  
  **Note:** AdminRepository est défini dans CLASSES_AUTH.puml
  Utilisé pour valider l'identité de l'admin lors des opérations
  
  **Méthode rejectMembershipRequest():**
  - Valide le motif (10-500 caractères)
  - Met à jour statut à 'rejected' avec motifReject, processedBy, processedAt
  - Crée notification Firestore pour admins (type: membership_rejected)
  - Retourne void
  
  **Méthode reopenMembershipRequest():**
  - Valide que statut = 'rejected'
  - Valide le motif de réouverture (10-500 caractères)
  - Met à jour statut à 'under_review' avec reopenReason, reopenedBy, reopenedAt
  - Crée notification Firestore pour admins (type: membership_reopened)
  - Retourne void
end note

class RegistrationService {
  - repository: IRegistrationRepository
  + submitRegistration(data: RegisterFormData): Promise<string>
  + updateRegistration(requestId: string, data: RegisterFormData): Promise<boolean>
  + verifySecurityCode(requestId: string, code: string): Promise<boolean>
  + loadRegistrationForCorrection(requestId: string): Promise<RegisterFormData | null>
  + validateStep(step: number, data: Partial<RegisterFormData>): Promise<StepValidationResult>
}

' ============================================
' CLASSES : REPOSITORIES (Architecture V2)
' ============================================

class MembershipRepositoryV2 {
  - collectionName: string
  - paymentRepository: PaymentRepositoryV2
  + {static} getInstance(): MembershipRepositoryV2
  + getById(id: string): Promise<MembershipRequest | null>
  + updateStatus(id: string, status: MembershipRequestStatus, data: Partial<MembershipRequest>): Promise<void>
  + markAsPaid(id: string, paymentInfo: PaymentInfo): Promise<void>
  + getPaginated(filters: MembershipRequestFilters): Promise<MembershipRequestsResponse>
}

class RegistrationRepository {
  + getById(id: string): Promise<MembershipRequest | null>
  + create(data: RegisterFormData): Promise<string>
  + update(id: string, data: Partial<RegisterFormData>): Promise<boolean>
  + verifySecurityCode(requestId: string, code: string): Promise<boolean>
  + markSecurityCodeAsUsed(requestId: string): Promise<boolean>
}

note right of DocumentRepository
  **Repository pour accès aux documents Firestore**
  
  **Défini dans:** CLASSES_SHARED.puml
  
  **Package:** src/domains/infrastructure/documents/repositories/
  
  **Utilisé par:**
  - resolveAdhesionPdfUrl() pour fallback PDF adhésion
  
  **Méthodes utilisées:**
  - getDocuments({ memberId, type: 'ADHESION', sort: [{ field: 'createdAt', direction: 'desc' }] })
  
  **Collection:** documents
  **Filtres:** memberId (matricule), type='ADHESION', orderBy createdAt (desc)
end note

' ============================================
' CLASSES : CLOUD FUNCTIONS
' ============================================

class ApproveMembershipRequestCloudFunction {
  + {callable} approveMembershipRequest(input: ApproveMembershipRequestInput): Promise<ApproveMembershipRequestOutput>
  - validateRequest(requestId: string): Promise<MembershipRequest>
  - generateEmail(firstName: string, lastName: string, matricule: string): string
  - generateSecurePassword(length: number): string
  - createFirebaseAuthUser(matricule: string, email: string, password: string): Promise<UserRecord>
  - createUserDocument(matricule: string, data: UserData): Promise<void>
  - createSubscription(memberId: string, membershipType: MembershipType, adhesionPdfURL: string): Promise<string>
  - archiveAdhesionDocument(matricule: string, adhesionPdfURL: string): Promise<string>
  - createApprovalNotification(requestId: string, matricule: string, memberName: string, email: string, adminId: string): Promise<void>
  - rollback(actions: RollbackAction[]): Promise<void>
}

class DeleteMembershipRequestCloudFunction {
  + {callable} deleteMembershipRequest(input: DeleteMembershipRequestInput): Promise<DeleteMembershipRequestOutput>
  - validatePermissions(auth: any): void
  - validateRequest(requestId: string): Promise<MembershipRequest>
  - validateMatricule(request: MembershipRequest, confirmedMatricule: string): void
  - createAuditLog(requestId: string, request: MembershipRequest, adminId: string): Promise<void>
  - deleteStorageFiles(request: MembershipRequest): Promise<number>
  - deleteFirestoreDocument(requestId: string): Promise<void>
}

class OnMembershipRequestRejectedCloudFunction {
  + {trigger} onMembershipRequestRejected(event: FirestoreEvent): Promise<void>
  - detectStatusChange(before: any, after: any): boolean
  - sendEmailNotification(request: MembershipRequest): Promise<void>
  - sendSMSNotification(request: MembershipRequest): Promise<void>
}

note right of OnMembershipRequestRejectedCloudFunction
  **Cloud Function Trigger (optionnel/non prioritaire)**
  
  **Déclencheur:** Changement de statut vers 'rejected'
  
  **Objectif:** Envoyer automatiquement email/SMS au demandeur
  
  **Priorité:** ⚠️ Optionnel / Non prioritaire
  
  **État:** À implémenter dans une phase ultérieure
  
  **Alternative:** Bouton WhatsApp manuel disponible dans l'interface admin
  
  **Fichier:** functions/src/membership-requests/onMembershipRequestRejected.ts
end note

' ============================================
' CLASSES : UTILITAIRES
' ============================================

class SecurityCodeUtils {
  + {static} generateSecurityCode(): string
  + {static} calculateCodeExpiry(hours: number): Date
}

class WhatsAppUrlUtils {
  + {static} generateWhatsAppUrl(phoneNumber: string, message: string): string
  + {static} generateRejectionWhatsAppUrl(phoneNumber: string, firstName: string, matricule: string, motifReject: string): string
}

class PDFGenerator {
  + {static} generateCredentialsPDF(firstName: string, lastName: string, matricule: string, email: string, password: string): Blob
  + {static} downloadPDF(blob: Blob, filename: string): void
}

' ============================================
' CLASSES : UTILITAIRES VUE DÉTAILS
' ============================================

class DetailsUtils {
  + {static} formatDateDetailed(timestamp: Date | Timestamp | string | null | undefined): string
  + {static} isDateExpired(timestamp: Date | Timestamp | string | null | undefined): boolean
  + {static} formatAddress(address: AddressData): string
  + {static} resolveAdhesionPdfUrl(params: ResolveAdhesionPdfUrlParams): Promise<string | null>
}

class ResolveAdhesionPdfUrlParams {
  + id: string
  + matricule?: string
  + adhesionPdfURL?: string | null
  + status: MembershipRequestStatus
}

note right of DetailsUtils
  **Utilitaires pour la vue détails d'une demande d'adhésion**
  
  **formatDateDetailed():**
  - Formate une date (Date, Firestore Timestamp, string) en format français détaillé
  - Gère les valeurs null/undefined → "Non définie"
  - Gère les dates invalides → "Date invalide"
  
  **isDateExpired():**
  - Vérifie si une date est dans le passé
  - Compare à aujourd'hui (heure réinitialisée à 00:00:00)
  - Retourne false si date null/undefined/invalide
  
  **formatAddress():**
  - Formate une adresse complète depuis AddressData
  - Filtre les champs vides/null
  - Retourne "Non renseignée" si tous les champs sont vides
  
  **resolveAdhesionPdfUrl():**
  - Résout l'URL du PDF d'adhésion validé
  - Priorité: adhesionPdfURL direct → Fallback Firestore documents (type ADHESION)
  - Retourne null si aucun PDF trouvé
  - Utilise DocumentRepository pour requête Firestore
end note

' ============================================
' CLASSES : HOOKS VUE DÉTAILS
' ============================================

class useMembershipRequestDetails {
  + request: MembershipRequest | null
  + admin: any | null
  + intermediary: any | null
  + adhesionPdfUrlResolved: string | null
  + isLoading: boolean
  + isError: boolean
  + error: unknown
}

note right of useMembershipRequestDetails
  **Hook React Query agrégateur pour la vue détails**
  
  **Fonctionnalités:**
  - Récupère la demande via MembershipRepositoryV2.getById()
  - Récupère l'admin traiteur via getAdminById(processedBy)
  - Récupère l'intermédiaire via useIntermediary(intermediaryCode)
  - Résout l'URL du PDF d'adhésion via resolveAdhesionPdfUrl()
  
  **Gestion des états:**
  - isLoading: true si au moins une requête est en cours
  - isError: true si au moins une requête a échoué
  - error: Première erreur rencontrée
  
  **Cache React Query:**
  - Évite les appels multiples pour les mêmes données
  - staleTime: 5 minutes (admin, PDF), selon MEMBERSHIP_REQUEST_CACHE (request)
  - gcTime: 10 minutes (admin, PDF), selon MEMBERSHIP_REQUEST_CACHE (request)
end note

' ============================================
' CLASSES : COMPOSANTS VUE DÉTAILS
' ============================================

' Composant principal refactorisé
class MembershipRequestDetails {
  + render(): JSX.Element
  - handleViewAdhesionPdf(): Promise<void>
}

' Composants de base
class DetailsSkeleton {
  + render(): JSX.Element
}

class DetailsErrorState {
  + error?: unknown
  + onRetry?: () => void
  + render(): JSX.Element
}

' Composants partagés
class InfoField {
  + label: string
  + value: string | React.ReactNode
  + icon?: React.ComponentType
  + color?: string
  + copyable?: boolean
  + render(): JSX.Element
}

class ModernCard {
  + title: string
  + icon: React.ComponentType
  + children: React.ReactNode
  + className?: string
  + iconColor?: string
  + render(): JSX.Element
}

' Composants de sections
class DetailsHeaderStatus {
  + request: MembershipRequest
  + render(): JSX.Element
}

class DetailsIdentityCard {
  + request: MembershipRequest
  + intermediaryInfo?: IntermediaryInfo | null
  + isLoadingIntermediary?: boolean
  + render(): JSX.Element
}

class DetailsContactCard {
  + request: MembershipRequest
  + render(): JSX.Element
}

class DetailsAddressCard {
  + request: MembershipRequest
  + render(): JSX.Element
}

class DetailsEmploymentCard {
  + request: MembershipRequest
  + intermediaryInfo?: IntermediaryInfo | null
  + render(): JSX.Element
}

class DetailsPaymentCard {
  + request: MembershipRequest
  + render(): JSX.Element
}

class DetailsDocumentsCard {
  + request: MembershipRequest
  + adhesionPdfUrlResolved?: string | null
  + onViewAdhesionPdf?: () => void
  + render(): JSX.Element
}

class DetailsMetaCard {
  + request: MembershipRequest
  + admin?: AdminInfo | null
  + isLoadingAdmin?: boolean
  + render(): JSX.Element
}

class DetailsPhotoCard {
  + request: MembershipRequest
  + render(): JSX.Element
}

' Types auxiliaires
class IntermediaryInfo {
  + firstName: string
  + lastName: string
  + type: 'user' | 'admin'
}

class AdminInfo {
  + firstName?: string
  + lastName?: string
}

note right of MembershipRequestDetails
  **Composant principal refactorisé (Phase 4)**
  
  **Architecture:**
  - Utilise useMembershipRequestDetails() pour agrégation des données
  - Composition de 9 sous-composants présentatifs
  - Gestion des états: loading (skeleton), error (error state), success (sections)
  
  **Réduction de code:**
  - Avant: 834 lignes (monolithe)
  - Après: ~150 lignes (composition)
  
  **Fonctionnalités:**
  - handleViewAdhesionPdf(): Gère l'ouverture du PDF avec fallback Firestore
  - Affichage conditionnel selon le statut (PDF visible si approved)
end note

note right of DetailsUtils
  **Package:** src/domains/memberships/utils/details/
  
  **Fichiers:**
  - formatDateDetailed.ts
  - isDateExpired.ts
  - formatAddress.ts
  - resolveAdhesionPdfUrl.ts
  - index.ts (exports)
  
  **Tests:** 100% couverture (Phase 1)
end note

note right of useMembershipRequestDetails
  **Package:** src/domains/memberships/hooks/
  
  **Fichier:** useMembershipRequestDetails.ts
  
  **Dépendances:**
  - MembershipRepositoryV2
  - getAdminById (db/admin.db)
  - useIntermediary (hooks/useIntermediary)
  - resolveAdhesionPdfUrl (utils/details)
  
  **Tests:** ≥80% couverture (Phase 2)
end note

note right of MembershipRequestDetails
  **Package:** src/components/memberships/
  
  **Fichier:** MembershipRequestDetails.tsx
  
  **Composants utilisés:**
  - DetailsHeaderStatus
  - DetailsIdentityCard
  - DetailsContactCard
  - DetailsAddressCard
  - DetailsEmploymentCard
  - DetailsPaymentCard
  - DetailsDocumentsCard
  - DetailsPhotoCard
  - DetailsMetaCard
  - DetailsSkeleton (loading)
  - DetailsErrorState (error)
end note

note right of DetailsIdentityCard
  **Package:** src/domains/memberships/components/details/
  
  **Fonctionnalités:**
  - Affiche toutes les informations d'identité
  - Affiche le parrain/intermédiaire si code présent
  - Affiche le statut véhicule (hasCar)
  - Utilise formatDateDetailed() pour dates
  - Utilise getNationalityName() pour nationalité
end note

note right of DetailsDocumentsCard
  **Fonctionnalités:**
  - Affiche le bouton "Adhésion PDF" si statut = approved
  - Gère l'ouverture du PDF (URL directe ou fallback)
  - Affiche les pièces d'identité (recto/verso)
  - Utilise isDateExpired() pour badge expiration
  - Utilise formatDateDetailed() pour dates
end note

' ============================================
' TYPES ENUMERÉS
' ============================================
enum MembershipRequestStatus {
  pending
  approved
  rejected
  under_review
}

enum PaymentMode {
  airtel_money
  mobicash
  cash
  bank_transfer
  other
}

enum TypePayment {
  Membership
  Subscription
  Tontine
  Charity
}

enum MembershipType {
  adherant
  bienfaiteur
  sympathisant
}

' ============================================
' RELATIONS
' ============================================

' MembershipRequest contient IdentityData (composition)
MembershipRequest *-- IdentityData : contains

' MembershipRequest contient AddressData (composition)
MembershipRequest *-- AddressData : contains

' MembershipRequest contient CompanyData (composition)
MembershipRequest *-- CompanyData : contains

' MembershipRequest contient DocumentsData (composition)
MembershipRequest *-- DocumentsData : contains

' CompanyData contient CompanyAddressData (composition)
CompanyData *-- CompanyAddressData : contains

' MembershipRequest peut devenir User (après validation)
MembershipRequest ..> User : becomes

' MembershipRequest peut avoir plusieurs Payment (agrégation)
MembershipRequest "1" --> "*" Payment : has

' User peut avoir plusieurs Subscription (agrégation)
User "1" --> "*" Subscription : has

' Group référence User (via membres dans User, pas de relation directe dans Firestore)
' Note: Les groupes stockent les IDs des membres dans User.groups ou via une sous-collection
User "1" --> "*" Group : belongs_to

' User peut avoir plusieurs Documents (agrégation - référencé depuis Shared)
User "1" --> "*" Document : has

' ============================================
' RELATIONS : FONCTIONNALITÉ CORRECTIONS
' ============================================

' MembershipRequest peut avoir une CorrectionRequest active
MembershipRequest ..> CorrectionRequest : can have

' RegisterFormData utilise les mêmes structures de données que MembershipRequest
RegisterFormData *-- IdentityData : contains
RegisterFormData *-- AddressData : contains
RegisterFormData *-- CompanyData : contains
RegisterFormData *-- DocumentsData : contains

' ============================================
' RELATIONS : FONCTIONNALITÉ APPROBATION
' ============================================

' MembershipRequest peut être approuvée via Cloud Function
MembershipRequest ..> ApproveMembershipRequestCloudFunction : approved_by

' MembershipRequest génère un Document (PDF d'adhésion) lors de l'approbation
MembershipRequest "1" --> "0..1" Document : generates_adhesion_pdf
note right of Document
  **Type:** ADHESION
  **Format:** pdf
  **Créé lors de l'approbation**
  **Stocké dans collection "documents"**
end note

' ApproveMembershipRequestInput est utilisé par la Cloud Function
ApproveMembershipRequestCloudFunction ..> ApproveMembershipRequestInput : uses
ApproveMembershipRequestCloudFunction ..> ApproveMembershipRequestOutput : returns

' DeleteMembershipRequestInput est utilisé par la Cloud Function
DeleteMembershipRequestCloudFunction ..> DeleteMembershipRequestInput : uses
DeleteMembershipRequestCloudFunction ..> DeleteMembershipRequestOutput : returns

' Cloud Function crée un User lors de l'approbation
ApproveMembershipRequestCloudFunction ..> User : creates

' Cloud Function crée une Subscription lors de l'approbation
ApproveMembershipRequestCloudFunction ..> Subscription : creates

' Cloud Function archive un Document lors de l'approbation
ApproveMembershipRequestCloudFunction ..> Document : archives

' Cloud Function crée un log d'audit lors de la suppression
DeleteMembershipRequestCloudFunction ..> AuditLog : creates

' MembershipRequest peut générer des Notifications
MembershipRequest "1" --> "*" Notification : generates

' Cloud Function peut créer des Notifications
MembershipServiceV2 ..> Notification : creates

' Services utilisent leurs paramètres
MembershipServiceV2 ..> RejectMembershipRequestParams : uses
MembershipServiceV2 ..> ReopenMembershipRequestParams : uses

' Services utilisent leurs repositories respectifs
MembershipServiceV2 --> MembershipRepositoryV2 : uses
MembershipServiceV2 --> AdminRepository : uses
MembershipServiceV2 --> NotificationService : uses
RegistrationService --> RegistrationRepository : uses

' MembershipServiceV2 appelle la Cloud Function pour l'approbation
MembershipServiceV2 ..> ApproveMembershipRequestCloudFunction : calls

' MembershipServiceV2 appelle la Cloud Function pour la suppression
MembershipServiceV2 ..> DeleteMembershipRequestCloudFunction : calls

' Repositories interagissent avec MembershipRequest
MembershipRepositoryV2 ..> MembershipRequest : queries/updates
RegistrationRepository ..> MembershipRequest : queries/updates

' Services utilisent les utilitaires
MembershipServiceV2 ..> SecurityCodeUtils : uses
MembershipServiceV2 ..> WhatsAppUrlUtils : uses
MembershipServiceV2 ..> PDFGenerator : uses

' ============================================
' RELATIONS : VUE DÉTAILS
' ============================================

' Composant principal utilise le hook
MembershipRequestDetails --> useMembershipRequestDetails : uses

' Hook utilise les repositories et utilitaires
useMembershipRequestDetails --> MembershipRepositoryV2 : uses
useMembershipRequestDetails --> DetailsUtils : uses
useMembershipRequestDetails ..> User : queries_admin
useMembershipRequestDetails ..> Document : queries_pdf

' Composant principal compose les sous-composants
MembershipRequestDetails *-- DetailsSkeleton : uses_loading
MembershipRequestDetails *-- DetailsErrorState : uses_error
MembershipRequestDetails *-- DetailsHeaderStatus : uses
MembershipRequestDetails *-- DetailsIdentityCard : uses
MembershipRequestDetails *-- DetailsContactCard : uses
MembershipRequestDetails *-- DetailsAddressCard : uses
MembershipRequestDetails *-- DetailsEmploymentCard : uses
MembershipRequestDetails *-- DetailsPaymentCard : uses
MembershipRequestDetails *-- DetailsDocumentsCard : uses
MembershipRequestDetails *-- DetailsPhotoCard : uses
MembershipRequestDetails *-- DetailsMetaCard : uses

' Sous-composants utilisent les composants partagés
DetailsIdentityCard --> InfoField : uses
DetailsIdentityCard --> ModernCard : uses
DetailsContactCard --> InfoField : uses
DetailsContactCard --> ModernCard : uses
DetailsAddressCard --> InfoField : uses
DetailsAddressCard --> ModernCard : uses
DetailsEmploymentCard --> InfoField : uses
DetailsEmploymentCard --> ModernCard : uses
DetailsPaymentCard --> ModernCard : uses
DetailsDocumentsCard --> ModernCard : uses
DetailsMetaCard --> InfoField : uses
DetailsMetaCard --> ModernCard : uses
DetailsPhotoCard --> ModernCard : uses
DetailsHeaderStatus --> ModernCard : uses

' Sous-composants utilisent les utilitaires
DetailsIdentityCard ..> DetailsUtils : uses_formatDateDetailed
DetailsAddressCard ..> DetailsUtils : uses_formatAddress
DetailsDocumentsCard ..> DetailsUtils : uses_isDateExpired
DetailsDocumentsCard ..> DetailsUtils : uses_formatDateDetailed
DetailsMetaCard ..> DetailsUtils : uses_formatDateDetailed

' Sous-composants reçoivent les données
DetailsIdentityCard ..> MembershipRequest : receives
DetailsIdentityCard ..> IntermediaryInfo : receives
DetailsContactCard ..> MembershipRequest : receives
DetailsAddressCard ..> MembershipRequest : receives
DetailsEmploymentCard ..> MembershipRequest : receives
DetailsEmploymentCard ..> IntermediaryInfo : receives
DetailsPaymentCard ..> MembershipRequest : receives
DetailsDocumentsCard ..> MembershipRequest : receives
DetailsMetaCard ..> MembershipRequest : receives
DetailsMetaCard ..> AdminInfo : receives
DetailsPhotoCard ..> MembershipRequest : receives
DetailsHeaderStatus ..> MembershipRequest : receives

' Hook utilise resolveAdhesionPdfUrl avec paramètres
useMembershipRequestDetails ..> ResolveAdhesionPdfUrlParams : uses
DetailsUtils ..> ResolveAdhesionPdfUrlParams : uses
DetailsUtils --> DocumentRepository : queries_fallback

' DocumentRepository interroge Document
DocumentRepository ..> Document : queries

' NotificationService crée des notifications pour les admins
MembershipServiceV2 ..> NotificationService : creates_notifications
NotificationService ..> Notification : creates

' RegistrationRepository utilise SecurityCodeUtils pour marquer le code comme utilisé
RegistrationRepository ..> SecurityCodeUtils : uses

note right of MembershipRequest
  **Collection Firestore:** membership-requests
  Clé primaire: id
  Index sur: status, createdAt, matricule, isPaid, approvedBy, approvedAt, processedBy, processedAt
  
  **Workflow métier:**
  - isPaid: false par défaut (migration appliquée)
  - Paiement requis avant approbation
  - Filtrage par statut de paiement (Payées/Non payées)
  
  **Fonctionnalité Corrections:**
  - reviewNote: Liste des corrections demandées
  - securityCode: Code à 6 chiffres (généré aléatoirement)
  - securityCodeExpiry: Expiration 48h après génération
  - securityCodeUsed: Marqué à true après utilisation
  - Statut passe à 'under_review' lors de la demande de correction
  - Statut repasse à 'pending' après soumission des corrections
  
  **Fonctionnalité Approbation:**
  - approvedBy: ID de l'admin qui a approuvé (obligatoire, pour traçabilité)
  - approvedAt: Date d'approbation (obligatoire, timestamp serveur)
  - Statut passe à 'approved' après approbation
  - Génère un User, une Subscription et un Document (PDF d'adhésion)
  - Ces champs permettent l'audit et la traçabilité des approbations
  
  **Fonctionnalité Rejet:**
  - motifReject: Motif de rejet (obligatoire, 10-500 caractères)
  - processedBy: ID de l'admin qui a rejeté (obligatoire, pour traçabilité)
  - processedAt: Date de rejet (obligatoire, timestamp serveur)
  - Statut passe à 'rejected' après rejet
  - Notification Firestore créée pour tous les admins (type: membership_rejected)
  - Bouton WhatsApp manuel disponible pour informer le demandeur
  
  **Fonctionnalité Réouverture:**
  - reopenReason: Motif de réouverture (obligatoire, 10-500 caractères)
  - reopenedBy: ID de l'admin qui a réouvert (obligatoire, pour traçabilité)
  - reopenedAt: Date de réouverture (obligatoire, timestamp serveur)
  - Statut passe de 'rejected' à 'under_review' après réouverture
  - Notification Firestore créée pour tous les admins (type: membership_reopened)
end note

note right of MembershipServiceV2
  **Service métier V2 pour Membership Requests**
  
  **Méthode requestCorrections():**
  - Valide les corrections (non vide, chaque ligne non vide)
  - Génère securityCode (6 chiffres)
  - Calcule securityCodeExpiry (+48h)
  - Met à jour statut à 'under_review'
  - Génère URL WhatsApp si numéro disponible
  - Retourne {securityCode, whatsAppUrl}
  
  **Méthode approveMembershipRequest():**
  - Valide les paramètres (requestId, adminId, membershipType, adhesionPdfURL)
  - Upload PDF d'adhésion vers Firebase Storage
  - Appelle Cloud Function approveMembershipRequest
  - Génère et télécharge PDF des identifiants (email + password)
  - Retourne ApproveMembershipRequestOutput
  
  **Architecture:**
  - Singleton pattern
  - Utilise MembershipRepositoryV2 pour accès données
  - Utilise AdminRepository pour validation admin
  - Appelle Cloud Function pour approbation atomique
end note

note right of RegistrationService
  **Service pour la gestion des inscriptions et corrections**
  
  **Méthodes principales:**
  - verifySecurityCode(): Vérifie code (format, correspondance, expiration, usage)
  - loadRegistrationForCorrection(): Charge données demande pour pré-remplir formulaire
  - updateRegistration(): Met à jour demande avec corrections (status → 'pending', securityCodeUsed → true)
  - submitRegistration(): Crée nouvelle demande
  
  **Architecture:**
  - Utilise RegistrationRepository pour accès données
  - Transforme MembershipRequest ↔ RegisterFormData
end note

note right of SecurityCodeUtils
  **Utilitaires pour codes de sécurité**
  
  **generateSecurityCode():**
  - Génère code aléatoire à 6 chiffres (100000-999999)
  - Utilise crypto.randomInt() pour sécurité
  
  **calculateCodeExpiry(hours: number):**
  - Calcule date d'expiration
  - Par défaut: 48 heures après génération
  - Retourne Date
end note

note right of WhatsAppUrlUtils
  **Utilitaires pour génération URLs WhatsApp**
  
  **generateWhatsAppUrl(phoneNumber, message):**
  - Formate numéro (supprime espaces, +, etc.)
  - Encode message en URL
  - Retourne URL format: https://wa.me/{phoneNumber}?text={encodedMessage}
  
  **generateRejectionWhatsAppUrl(phoneNumber, firstName, matricule, motifReject):**
  - Génère URL WhatsApp avec template de message de rejet
  - Message pré-rempli avec motif de rejet
  - Utilisé pour notifier le demandeur du rejet
  
  **Utilisation:**
  - Admin peut sélectionner parmi plusieurs numéros
  - Message pré-rempli avec corrections et code de sécurité (corrections)
  - Message pré-rempli avec motif de rejet (rejet)
end note

note right of ApproveMembershipRequestCloudFunction
  **Cloud Function Callable pour approbation atomique**
  
  **Opérations atomiques:**
  1. Validation (paiement, statut, permissions)
  2. Génération email et mot de passe
  3. Création utilisateur Firebase Auth
  4. Création document users
  5. Création abonnement subscriptions
  6. Archivage document PDF (collection documents)
  7. Mise à jour statut membership-requests
  8. Création notification
  
  **Workflow PDF d'adhésion:**
  1. Admin upload PDF dans le modal d'approbation
  2. PDF uploadé vers Firebase Storage (chemin: membership-adhesion-pdfs/)
  3. URL du PDF récupérée (adhesionPdfURL)
  4. Cloud Function archive dans collection "documents"
  5. Document créé avec type='ADHESION', memberId=matricule
  
  **Rollback automatique:**
  - Si une étape échoue, annule toutes les opérations précédentes
  - Supprime User Auth, document users, subscription, document PDF
  - Note: PDF dans Storage reste (peut être nettoyé manuellement)
  
  **Sécurité:**
  - Mot de passe retourné uniquement dans la réponse HTTPS
  - Jamais stocké en Firestore
  - Firebase Auth gère le stockage sécurisé
  
  **Fichier:** functions/src/membership-requests/approveMembershipRequest.ts
end note

note right of PDFGenerator
  **Générateur de PDF pour identifiants de connexion**
  
  **generateCredentialsPDF():**
  - Utilise jsPDF pour générer PDF côté client
  - Contient: Logo KARA, informations membre, email, password
  - Format: Identifiants_Connexion_{matricule}_{date}.pdf
  
  **downloadPDF():**
  - Télécharge automatiquement le PDF généré
  - Appelé immédiatement après génération
  
  **Utilisation:**
  - Après approbation réussie
  - PDF contient les identifiants pour le membre
  - Téléchargement automatique pour l'admin
end note

note right of User
  **Collection Firestore:** users
  Clé primaire: id (égal à matricule et UID Firebase)
  Relation avec MembershipRequest: après validation
end note

note right of Group
  **Collection Firestore:** groups
  Clé primaire: id
  Relation avec User: indirecte (via User.groups ou sous-collection)
end note

note right of Subscription
  **Collection Firestore:** subscriptions
  Clé primaire: id
  Index sur: userId, dateStart, dateEnd
end note

@enduml
