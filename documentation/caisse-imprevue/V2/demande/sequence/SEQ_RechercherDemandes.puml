@startuml SEQ_RechercherDemandes
title Séquence : Rechercher des Demandes avec Cache (V2)

actor "Admin" as Admin
participant "DemandSearchV2\n(Component)" as Search
participant "useDebounce\n(Hook)" as Debounce
participant "useDemandSearch\n(Hook)" as SearchHook
participant "DemandCIRepository\n(Repository)" as Repo
database "Firestore" as Firestore
participant "React Query\n(Cache)" as QueryCache
participant "ListDemandesV2\n(Component)" as List

Admin -> Search: Tape "Glenn" dans recherche
activate Search

Search -> Debounce: useDebounce('Glenn', 300ms)
activate Debounce

Debounce -> Debounce: Attendre 300ms
Debounce -> Debounce: Si Admin continue à taper → annuler timer

alt Admin arrête de taper après 300ms
    Debounce --> Search: debouncedQuery = 'Glenn'
    deactivate Debounce
    
    Search -> Search: Normaliser query :
    Search -> Search: normalizedQuery = 'glenn'.toLowerCase().trim()
    
    Search -> SearchHook: useDemandSearch(normalizedQuery, filters)
    activate SearchHook
    
    SearchHook -> QueryCache: queryKey: ['demand-search', 'glenn', filters]
    QueryCache -> QueryCache: Vérifier cache (staleTime: 2 min)
    
    alt Cache recherche présent et frais
        QueryCache --> SearchHook: Résultats depuis cache
        SearchHook --> Search: { data: results[], isLoading: false }
        Search --> Admin: Afficher résultats IMMÉDIATEMENT (pas de loading)
    else Cache absent ou stale
        SearchHook -> Search: isLoading = true
        Search --> Admin: Afficher loading state
        
        SearchHook -> Repo: search('glenn', filters)
        activate Repo
        
        Repo -> Firestore: query(\n  collection('caisseImprevueDemands'),\n  where('memberLastName', '>=', 'glenn'),\n  where('memberLastName', '<=', 'glenn\uf8ff'),\n  orderBy('memberLastName', 'asc'),\n  limit(50)\n)
        Firestore --> Repo: QuerySnapshot
        
        Repo -> Repo: Transform documents → Demand[]
        Repo -> Repo: Filtrer aussi par prénom côté client :
        Repo -> Repo: results.filter(d => \n  d.memberFirstName?.toLowerCase().includes('glenn') ||\n  d.memberLastName?.toLowerCase().includes('glenn')\n)
        
        Repo --> SearchHook: Demand[]
        deactivate Repo
        
        SearchHook -> QueryCache: Mettre en cache (2 min)
        QueryCache -> QueryCache: Cache mis à jour
        
        SearchHook --> Search: { data: results[], isLoading: false }
        Search --> Admin: Afficher résultats
    end
    
    SearchHook -> List: onSearch(results)
    List -> List: Appliquer résultats recherche
    List --> Admin: Afficher liste filtrée
    
    deactivate SearchHook
else Admin continue à taper
    Debounce -> Debounce: Annuler timer précédent
    Debounce -> Debounce: Nouveau timer 300ms
    Debounce --> Search: (attente)
end

' ============================================
' RECHERCHE SUIVANTE (CACHE UTILISÉ)
' ============================================
alt Admin recherche "Glenn" à nouveau (dans les 2 min)
    Admin -> Search: Tape "Glenn" à nouveau
    Search -> Debounce: useDebounce('Glenn', 300ms)
    Debounce --> Search: debouncedQuery = 'Glenn'
    
    Search -> SearchHook: useDemandSearch('glenn', filters)
    SearchHook -> QueryCache: queryKey: ['demand-search', 'glenn', filters]
    QueryCache -> QueryCache: Cache présent et frais (< 2 min)
    QueryCache --> SearchHook: Résultats depuis cache
    SearchHook --> Search: { data: results[], isLoading: false }
    Search --> Admin: Afficher résultats IMMÉDIATEMENT\n(pas de requête serveur)
end

' ============================================
' EFFACER RECHERCHE
' ============================================
alt Admin efface la recherche
    Admin -> Search: Efface le champ
    Search -> Search: searchQuery = ''
    Search -> List: onSearch([])
    List -> List: Afficher liste complète
    List --> Admin: Liste non filtrée
end

deactivate Search

note right of QueryCache
  **Stratégie cache recherche** :
  - staleTime: 2 min (recherches peuvent changer rapidement)
  - gcTime: 5 min (garde en cache après inutilisation)
  - Normalisation query pour éviter doublons
  - Cache utilisé directement si présent
end note

note right of Repo
  **Recherche Firestore** :
  - Recherche par préfixe (>= et <=)
  - Nécessite index composite
  - Limite 50 résultats
  - Filtrage prénom côté client
  - Peut être amélioré avec Algolia
end note

@enduml
